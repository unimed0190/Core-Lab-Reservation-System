# app.py 
# ----------------------------------------------------

# 導入更多需要的函式，以便處理網頁請求、導向頁面和顯示訊息
from flask import Flask, render_template, request, redirect, url_for, flash 
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash 
from datetime import datetime, timedelta
from forms import InstrumentForm, RegistrationForm, LoginForm, ReservationForm, UserEditForm, SuperAdminForm, ServiceForm # 🚨 確保您已將 SuperAdminForm 導入

# 導入 os 模組用於路徑操作
import os 
# 導入 secure_filename 函式，用於安全處理上傳檔案名稱
from werkzeug.utils import secure_filename

# 導入 Flask-Login 相關模組
from flask_login import LoginManager, UserMixin, login_user, logout_user, current_user, login_required 

# 儀器詳情路由：處理顯示頁面 (GET) 和預約提交 (POST)

# 初始化 Flask 應用程式
app = Flask(__name__)


# ====== 1. 資料庫配置 & 安全密鑰 (更新部分) ======

# 設置檔案上傳的目標資料夾
UPLOAD_FOLDER = 'static/instrument_images' 
# 確保 Flask 知道這個資料夾
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
# 確保這個資料夾存在
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# Flask-WTF 需要一個密鑰來保護您的表單安全 (防止 CSRF 攻擊)
# 請務必使用一個複雜的密鑰，這裡僅為範例
app.config['SECRET_KEY'] = 'your_super_secure_key_for_flask_wtf' 
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///reservations.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# 初始化 Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
# 設定未登入時會被導向的函式名稱
login_manager.login_view = 'login' 

# 這是 Flask-Login 用來從資料庫載入使用者的函式 (必備！)
@login_manager.user_loader
def load_user(user_id):
    # 這裡的 user_id 是字串，需要轉換成整數
    return User.query.get(int(user_id))
# 儀器列表頁面 (不需登入即可查看)
@app.route('/instruments')
def instruments():
    # 🌟 查詢資料庫：使用 Instrument.query.all() 獲取所有儀器
    instruments = Instrument.query.all()
    
    # 將查詢到的儀器清單傳遞給模板
    return render_template('instruments.html', instruments=instruments)

@login_required
@app.route('/instrument/<int:instrument_id>', methods=['GET', 'POST'])
def instrument_detail(instrument_id):
    # 1. 獲取儀器物件，找不到則返回404
    instrument = Instrument.query.get_or_404(instrument_id)
    
    # 2. 實例化預約表單
    form = ReservationForm()
    current_time = datetime.now() 
    
    # ----------------------------------------------------------------------
    # 3. 處理表單提交 (POST 請求) 
    # ----------------------------------------------------------------------
    if form.validate_on_submit():
        start_time = form.start_time.data
        end_time = form.end_time.data
        
        # 3.1. 執行預約衝突檢查查詢
        conflict_reservations = Reservation.query.filter(
            Reservation.instrument_id == instrument.id,
            Reservation.status.in_(['confirmed', 'pending']), # 檢查已確認和待審核的預約
            Reservation.start_time < end_time,
            Reservation.end_time > start_time
        ).all()
        
        # 3.2. 判斷是否有衝突
        if conflict_reservations:
            # 找到衝突，阻止預約並顯示錯誤
            flash('預約失敗：您選擇的時段與現有預約發生衝突！請檢查時間。', 'danger')
            # 程式碼將繼續執行到下方的 render_template
            
        elif start_time >= end_time:
            # 檢查時間順序
            flash('預約失敗：開始時間必須早於結束時間。', 'danger')
            # 程式碼將繼續執行到下方的 render_template
            
        else:
            # 3.3. 無衝突且時間有效，繼續處理預約寫入
            try:
                new_reservation = Reservation(
                    instrument_id=instrument.id,
                    user_id=current_user.id,
                    start_time=start_time,
                    end_time=end_time,
                    purpose=form.purpose.data,
                    status='pending'
                )
                
                db.session.add(new_reservation)
                db.session.commit()
                
                flash('您的預約已提交成功，等待管理員審核。', 'success')
                
            except Exception as e:
                db.session.rollback()
                flash(f'預約提交時發生錯誤：{e}', 'danger')
                
            # 3.4. 提交成功後跳轉，防止二次提交
            return redirect(url_for('instrument_detail', instrument_id=instrument.id))

    
    # ----------------------------------------------------------------------
    # 4. 準備渲染頁面所需的數據 (不論是 GET 還是 POST 失敗，都會執行這裡)
    # ----------------------------------------------------------------------
    
    # 4.1. 設定表單預設時間 (僅在 GET 請求時設定，POST 失敗時表單會保留數據)
    if request.method == 'GET':
        now_clean = current_time.replace(second=0, microsecond=0)
        form.start_time.data = now_clean
        form.end_time.data = now_clean + timedelta(hours=2)

    # 4.2. 獲取已確認且尚未結束的預約清單 (這是修正 UnboundLocalError 的關鍵點)
    confirmed_reservations = Reservation.query.filter(
        Reservation.instrument_id == instrument.id,
        Reservation.status == 'confirmed',
        Reservation.end_time >= current_time
    ).order_by(Reservation.start_time.asc()).all()

    # 5. 返回渲染的模板 (這是唯一且正確的 render_template)
    return render_template('instrument_detail.html', 
                           form=form, 
                           instrument=instrument,
                           confirmed_reservations=confirmed_reservations)

# ----------------------------------------------------
# 🌟 新增：專案服務相關路由 🌟
# ----------------------------------------------------

# 專案服務列表頁面 (不需登入即可查看)
@app.route('/services')
def services():
    services_list = Service.query.all()
    # 假設您新增了 templates/services.html 模板
    return render_template('services.html', services=services_list)

# 專案服務詳情及預約路由
@login_required
@app.route('/service/<int:service_id>', methods=['GET', 'POST'])
def service_detail(service_id):
    service = Service.query.get_or_404(service_id)
    form = ReservationForm()
    current_time = datetime.now()

    if form.validate_on_submit():
        start_time = form.start_time.data
        end_time = form.end_time.data

        # 衝突檢查 (只檢查針對此服務的預約)
        conflict_reservations = Reservation.query.filter(
            Reservation.service_id == service.id, # 🌟 關鍵：檢查 service_id 🌟
            Reservation.status.in_(['confirmed', 'pending']),
            Reservation.start_time < end_time,
            Reservation.end_time > start_time
        ).all()

        if conflict_reservations:
            flash('預約失敗：您選擇的時段與現有預約發生衝突！', 'danger')
        elif start_time >= end_time:
            flash('預約失敗：開始時間必須早於結束時間。', 'danger')
        else:
            try:
                new_reservation = Reservation(
                    service_id=service.id,  # 🌟 寫入 service_id 🌟
                    user_id=current_user.id,
                    start_time=start_time,
                    end_time=end_time,
                    purpose=form.purpose.data,
                    status='pending'
                )
                
                # 執行自訂檢查 (確保只連結一個項目)
                if not new_reservation.is_valid():
                    raise ValueError("預約記錄必須且只能連結到一個服務或儀器。")

                db.session.add(new_reservation)
                db.session.commit()
                
                flash('您的專案服務預約已提交成功，等待管理員審核。', 'success')
                return redirect(url_for('service_detail', service_id=service.id))
            
            except Exception as e:
                db.session.rollback()
                flash(f'預約提交時發生錯誤：{e}', 'danger')
                
    
    # 4. 準備渲染頁面所需的數據 (GET 或 POST 失敗)
    if request.method == 'GET':
        now_clean = current_time.replace(second=0, microsecond=0)
        form.start_time.data = now_clean
        form.end_time.data = now_clean + timedelta(hours=2)

    # 獲取已確認且尚未結束的專案服務預約清單
    confirmed_reservations = Reservation.query.filter(
        Reservation.service_id == service.id, # 🌟 關鍵：檢查 service_id 🌟
        Reservation.status == 'confirmed',
        Reservation.end_time >= current_time
    ).order_by(Reservation.start_time.asc()).all()

    # 假設您新增了 templates/service_detail.html 模板
    return render_template('service_detail.html', 
                           form=form, 
                           service=service,
                           confirmed_reservations=confirmed_reservations)

# ====== 2. 儀器模型定義 (Instrument Model) ======
class Instrument(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    instrument_code = db.Column(db.String(100), unique=True, nullable=False)
    chinese_name = db.Column(db.String(100), nullable=False) 
    english_name = db.Column(db.String(100), nullable=False) 
    description = db.Column(db.Text) 
    image_url = db.Column(db.String(255)) 
    
    # 建立一個反向關係 (Back-reference)：讓儀器物件知道它有哪些預約紀錄
    reservations = db.relationship('Reservation', backref='instrument', lazy=True)

    def __repr__(self):
        return f'<Instrument {self.chinese_name}>'

# ====== 3. 使用者模型定義 (User Model) ======
# User 類別現在繼承 db.Model 和 UserMixin
class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    role = db.Column(db.String(20), default='researcher', nullable=False) # 'admin' 或 'researcher'
    full_name = db.Column(db.String(100), nullable=False) 
    affiliation = db.Column(db.String(100))
    unit = db.Column(db.String(100))
    phone_number = db.Column(db.String(20))
    
    # 建立一個反向關係：讓使用者物件知道他做了哪些預約
    reservations = db.relationship('Reservation', backref='user', lazy=True, 
                                   cascade="all, delete-orphan")

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User {self.full_name} ({self.role})>'

# ====== 4. 預約模型定義 (Reservation Model - 新增部分) ======
# 由於 Reservation 模型需要能連結到 Instrument 或 Service，
# 我們需要更新 Reservation 模型，讓它可以同時連結這兩個項目，但只能選一個。

# 🚨 修正 Reservation 模型，使其能同時支援 Instrument 和 Service
class Reservation(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    
    # 外來鍵：連結到 Instrument.id (可為空)
    instrument_id = db.Column(db.Integer, db.ForeignKey('instrument.id'), nullable=True) # 改為 nullable=True
    
    # 新增外來鍵：連結到 Service.id (可為空)
    service_id = db.Column(db.Integer, db.ForeignKey('service.id'), nullable=True) # 新增欄位
    
    # 外來鍵：連結到 User.id
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # 預約開始與結束時間
    start_time = db.Column(db.DateTime, nullable=False)
    end_time = db.Column(db.DateTime, nullable=False)
    
    # 預約目的
    purpose = db.Column(db.Text)
    
    # 狀態：預設為待審核
    status = db.Column(db.String(20), default='pending', nullable=False) 
    
    # 紀錄建立時間：使用 default=datetime.utcnow 會在紀錄建立時自動寫入當前時間
    created_at = db.Column(db.DateTime, default=datetime.utcnow) 

    # 🌟 確保預約只屬於一項：檢查約束 (在寫入資料庫前要手動檢查)
    def is_valid(self):
        # 確保 instrument_id 和 service_id 兩者不都為空，且不都非空
        if (self.instrument_id is None and self.service_id is None) or \
           (self.instrument_id is not None and self.service_id is not None):
            return False
        return True

    def __repr__(self):
        return f'<Reservation ID:{self.id} for Instrument:{self.instrument_id} by User:{self.user_id}>'

# ====== 5. 專案服務模型定義 (Service Model - 新增) ======
class Service(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    # 🚨 修正 1: 專案代碼 (Service Code) 欄位
    service_code = db.Column(db.String(100), unique=True, nullable=False) 
    
    chinese_name = db.Column(db.String(100), nullable=False)
    # 🚨 修正 2: 缺少 English Name 欄位 (ServiceForm 中有，因此模型也必須有)
    english_name = db.Column(db.String(100)) # 假設不需要像代碼那樣 unique
    
    description = db.Column(db.Text)
    # 🚨 修正 3: 圖片 URL 欄位 (ServiceForm 中有，因此模型也必須有)
    image_url = db.Column(db.String(255)) 
    
    # 建立一個反向關係：讓服務物件知道它有哪些預約紀錄
    service_reservations = db.relationship('Reservation', backref='service', lazy=True)

    def __repr__(self):
        return f'<Service {self.chinese_name}>'

# ====== 6. 網站路由 (Routes) ======

@app.route('/')
def index(): # 👈 關鍵：這個函式名稱必須是 'index'
    # 我們也需要設定讓首頁能夠顯示快閃訊息，所以改用模板
    return render_template('base.html', title='儀器與專案服務預約系統')

# 確保使用者必須登入才能訪問這個頁面
@login_required
@app.route('/admin/add_instrument', methods=['GET', 'POST'])
def add_instrument():

    # 🌟 角色檢查開始 🌟
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！您沒有權限訪問此管理頁面。', 'danger')
        return redirect(url_for('index'))
    # 🌟 角色檢查結束 🌟

    # 只有 admin 角色才能執行下面的程式碼
    # 🌟 步驟 1: 創建表單實例 (這行必須在最前面)
    form = InstrumentForm() 

    # 檢查是否為 POST 提交且資料有效
    if form.validate_on_submit():

        image_filename = None
        # 🚨 關鍵：處理檔案上傳
        if form.image_file.data:
            # 獲取上傳的檔案

            # 確保檔案名稱安全
            filename = secure_filename(uploaded_file.filename)

            # 組合完整的儲存路徑
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)

            # 儲存檔案到伺服器
            uploaded_file.save(filepath)

            # 🌟 儲存檔案的相對路徑到資料庫 (使用相對路徑方便在 HTML 中顯示)
            image_filename = os.path.join('instrument_images', filename)

        # 1. 取得表單資料
        new_instrument = Instrument(
            chinese_name=form.chinese_name.data,
            english_name=form.english_name.data,
        description=form.description.data,
image_url=image_filename # 寫入檔案路徑 (e.g. 'instrument_images/my_file.jpg')
        )

        # 2. 將資料寫入資料庫
        db.session.add(new_instrument)
        db.session.commit()

        # 3. 給予成功訊息提示
        flash(f'儀器 "{new_instrument.chinese_name}" 已成功新增！', 'success')

        # 🌟 修正點：必須使用 new_instrument.id 🌟
        return redirect(url_for('instrument_detail', instrument_id=new_instrument.id))

    # 🌟 步驟 2: 如果是 GET 請求，或 POST 驗證失敗，就執行這行
    # 這確保了 'form' 永遠會被傳遞給模板s83
return render_template('add_instrument.html', form=form)

# ----------------------------------------------------
# 🌟 新增：管理員新增專案服務 🌟
# ----------------------------------------------------

@login_required
@app.route('/admin/add_service', methods=['GET', 'POST'])
def add_service():
    # 1. 權限檢查：只有 admin 或 super_admin 才能訪問
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！您沒有權限訪問此管理頁面。', 'danger')
        return redirect(url_for('index'))
        
    # 2. 創建表單實例
    form = ServiceForm() 
    
    if form.validate_on_submit():
        # 🚨 修正 1: 修正拼寫錯誤 'Noene' 為 None
        image_filename = None

        # 🚨 修正 2: 補回檔案上傳處理 (如果您的 ServiceForm 有 image_file 欄位)
        if hasattr(form, 'image_file') and form.image_file.data:
            uploaded_file = form.image_file.data
            filename = secure_filename(uploaded_file.filename)
            
            # 💡 建議：將服務圖片存入 service_images 資料夾以區分
            SERVICE_UPLOAD_FOLDER = 'static/service_images'
            if not os.path.exists(SERVICE_UPLOAD_FOLDER):
                os.makedirs(SERVICE_UPLOAD_FOLDER)
                
            filepath = os.path.join(SERVICE_UPLOAD_FOLDER, filename)
            uploaded_file.save(filepath)
            
            # 儲存相對路徑
            image_filename = os.path.join('service_images', filename) 


        # 3. 創建 Service 物件
        # 🚨 修正 3: 確保傳遞所有需要的欄位，例如 service_code, image_url
        new_service = Service(
            # 確保 Service 模型有這個欄位
            service_code=form.service_code.data, 
            chinese_name=form.chinese_name.data,
            english_name=form.english_name.data,
            description=form.description.data,
            image_url=image_filename # 寫入圖片路徑，如果沒有上傳，則為 None
        )

        # 4. 寫入資料庫 - 使用 try...except 處理潛在錯誤 (如 service_code 重複)
        try:
            db.session.add(new_service)
            db.session.commit()

            # 5. 提示並導向
            flash(f'專案服務 "{new_service.chinese_name}" 已成功新增！', 'success')
            # 🌟 導向到服務詳情頁面
            return redirect(url_for('service_detail', service_id=new_service.id))

        except Exception as e:
            db.session.rollback()
            # 🌟 增加錯誤提示：可能是 service_code 重複導致的 IntegrityError
            flash(f'新增專案服務失敗：代碼重複或資料庫錯誤。請檢查輸入。錯誤：{e}', 'danger')
            # 🌟 失敗時，返回到表單頁面
            return render_template('add_service.html', form=form)
            
    # 6. 渲染模板 (GET 請求或 POST 失敗)
    return render_template('add_service.html', form=form)

@login_required 
@app.route('/admin/reservations')
def admin_reservations():
    # 1. 權限檢查：只有 admin 才能訪問
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！您沒有權限訪問此管理頁面。', 'danger')
        return redirect(url_for('index'))
        
    # 2. 查詢資料庫：獲取所有狀態為 'pending' 的預約紀錄
    # 🌟 使用 filter_by 篩選出 instrument_id 和 status
    pending_reservations = Reservation.query.filter_by(
        status='pending'
    ).order_by(Reservation.created_at.asc()).all() # 按照建立時間升序排列
    
    # 3. 渲染模板
    return render_template('admin_reservations.html', 
                           pending_reservations=pending_reservations)

@login_required
# 🌟 修正點：明確指定只接受 POST 請求 (與 HTML 模板配合) 🌟
@app.route('/admin/approve/<int:reservation_id>', methods=['POST'])
def approve_reservation(reservation_id):
    # 1. 權限檢查：確保是 Admin 或 Super Admin
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！', 'danger')
        return redirect(url_for('index'))
    
    # 2. 查詢該預約紀錄
    reservation = Reservation.query.get_or_404(reservation_id)
    
    # 3. 檢查衝突 (重要！在批准前需要再次檢查)
    # 處理儀器預約的衝突檢查
    if reservation.instrument_id:
        conflict = Reservation.query.filter(
            Reservation.id != reservation_id,
            Reservation.instrument_id == reservation.instrument_id,
            Reservation.status == 'confirmed',
            Reservation.start_time < reservation.end_time,
            Reservation.end_time > reservation.start_time
        ).first()
    # 處理服務預約的衝突檢查
    elif reservation.service_id:
        conflict = Reservation.query.filter(
            Reservation.id != reservation_id,
            Reservation.service_id == reservation.service_id,
            Reservation.status == 'confirmed',
            Reservation.start_time < reservation.end_time,
            Reservation.end_time > reservation.start_time
        ).first()
    else:
        # 如果既沒有 instrument_id 也沒有 service_id (邏輯錯誤，但在這裡處理以防萬一)
        conflict = True 

    if conflict:
          # 發現衝突，拒絕批准
        flash(f'批准失敗：預約 ID {reservation_id} 與其他已確認預約衝突！', 'danger')
        return redirect(url_for('admin_reservations'))
    
    # 4. 無衝突，更新狀態為 'confirmed'
    reservation.status = 'confirmed'
    db.session.commit()
    
    flash(f'預約 ID {reservation_id} 已成功批准！', 'success')
    return redirect(url_for('admin_reservations'))

@login_required
# 🌟 修正點：明確指定只接受 POST 請求 (與 HTML 模板配合) 🌟
@app.route('/admin/reject/<int:reservation_id>', methods=['POST'])
def reject_reservation(reservation_id):
      # 1. 權限檢查：確保是 Admin 或 Super Admin
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！', 'danger')
        return redirect(url_for('index'))
    
      # 2. 查詢該預約紀錄
    reservation = Reservation.query.get_or_404(reservation_id)
    
    # 3. 更新狀態為 'rejected'
    reservation.status = 'rejected'
    db.session.commit()

    flash(f'預約 ID {reservation_id} 已成功拒絕！', 'info')
    return redirect(url_for('admin_reservations'))

#管理研究員路由

@login_required
@app.route('/admin/researchers')
def admin_researchers():
    # 權限檢查：Admin 和 Super Admin 都可以看
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！', 'danger')
        return redirect(url_for('index'))

    # 🌟 篩選邏輯：只查詢 role='user' 的使用者 🌟
    all_users = User.query.filter_by(role='user').all()

    # 注意：我們將使用新的模板 admin_researchers.html
    return render_template('admin_researchers.html', 
                            title='管理研究員', 
                            all_users=all_users)

#管理管理員路由

@login_required
@app.route('/admin/admins')
def admin_admins():
    # 權限檢查：Admin 和 Super Admin 都可以看
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！', 'danger')
        return redirect(url_for('index'))

    # 🌟 篩選邏輯：查詢 role 在 ['admin', 'super_admin'] 中的使用者 🌟
    allowed_admin_roles = ['admin', 'super_admin']
    all_users = User.query.filter(User.role.in_(allowed_admin_roles)).all()

    # 注意：我們將使用新的模板 admin_admins.html
    return render_template('admin_admins.html', 
                            title='管理管理員', 
                            all_users=all_users)

#權限提升路由 (User -> Admin)

@login_required 
@app.route('/admin/promote/<int:user_id>')
def promote_user(user_id):
    # 1. 權限檢查：確保是 Admin
    if current_user.role != 'super_admin':
        flash('權限不足！只有總管理員才能提升其他使用者為 Admin。', 'danger')
        return redirect(url_for('admin_researchers')) # 導向回使用者列表

    # 2. 查詢該使用者紀錄
    user_to_promote = User.query.get_or_404(user_id)

    # 3. 檢查：防止 Admin 自己提升自己（雖然無意義，但安全起見）
    if user_to_promote.role == 'admin':
        flash(f'使用者 {user_to_promote.email} 已經是 Admin 角色。', 'info')
        return redirect(url_for('admin_researchers'))

    # 4. 更新狀態為 'admin'
    user_to_promote.role = 'admin'
    db.session.commit() # 🌟 提交變更到資料庫 🌟

    flash(f'使用者 {user_to_promote.email} 已成功提升為 Admin 角色！', 'success')
    return redirect(url_for('admin_researchers'))

#編輯使用者資料 (Edit User Route)

# 導入 UserEditForm (假設您在 forms.py 中定義了此表單)
# 確保您已經在 forms.py 中定義了 UserEditForm
# 編輯使用者路由 (供 Super Admin 使用)
@login_required
@app.route('/admin/user/edit/<int:user_id>', methods=['GET', 'POST'])
def edit_user(user_id):
    # 1. 權限檢查：只有 Super Admin 才能編輯使用者
    if current_user.role != 'super_admin':
        flash('權限不足！只有總管理員才能編輯使用者資料或重設密碼。', 'danger')
        # 根據用戶角色，導向正確的列表頁面
        if User.query.get(user_id) and User.query.get(user_id).role == 'user':
            return redirect(url_for('admin_researchers'))
        else:
            return redirect(url_for('admin_admins'))

    # 2. 獲取要編輯的使用者物件
    user_to_edit = User.query.get_or_404(user_id)
    form = UserEditForm(obj=user_to_edit) # 將現有資料載入到表單中

    if form.validate_on_submit():
        # A. 處理基本資料更新
        user_to_edit.full_name = form.full_name.data
        user_to_edit.affiliation = form.affiliation.data
        if hasattr(form, 'phone_number'): # 檢查表單是否有此欄位 (如果 forms.py 有定義)
        user_to_edit.phone_number = form.phone_number.data

    # B. 處理密碼重設 (選填)
        if form.new_password.data:
            # 由於密碼重設在表單驗證時（confirmpassword 欄位）已經檢查過兩次輸入是否一致
            # 這裡直接設定新密碼
            user_to_edit.set_password(form.new_password.data)
            flash('密碼已成功重設。', 'success')

        # C. 提交變更
        db.session.commit()
        flash(f'使用者 {user_to_edit.email} 的資料已成功更新。', 'success')

        # D. 導向回正確的列表頁面
        if user_to_edit.role == 'user':
            return redirect(url_for('admin_researchers'))
        else:
             return redirect(url_for('admin_admins'))

    # 3. 渲染模板 (GET 請求或表單驗證失敗)
    # 傳入 user 物件以便模板中顯示只讀的 email/role
    return render_template('edit_user.html', 
                            title='編輯使用者資料', 
                            form=form, 
                            user=user_to_edit)

#權限移除路由 (Admin -> User)

@login_required 
@app.route('/admin/demote/<int:user_id>')
def demote_user(user_id):
    # 1. 權限檢查：只允許 Super Admin 訪問
    if current_user.role != 'super_admin':
        flash('權限不足！只有總管理員才能變更管理員權限。', 'danger')
        return redirect(url_for('admin_admins'))

    user_to_demote = User.query.get_or_404(user_id)

    # 2. 防護檢查：不可移除自己的權限 (Super Admin不能降級自己)
    if user_to_demote.id == current_user.id:
        flash('您不能移除自己的權限！', 'danger')
        return redirect(url_for('admin_admins'))

    # 3. 邏輯 A：將 Super Admin 降級為 Admin
    if user_to_demote.role == 'super_admin':
        user_to_demote.role = 'admin'
        db.session.commit() # 🌟 寫入資料庫 🌟
        flash(f'使用者 {user_to_demote.email} 已降級為 Admin 角色。', 'success')
    # 4. 邏輯 B：將 Admin 降級為 User
    elif user_to_demote.role == 'admin':
        user_to_demote.role = 'user'
        db.session.commit() # 🌟 寫入資料庫 🌟
        flash(f'使用者 {user_to_demote.email} 已降級為 User 角色。', 'success')

    # 5. 如果使用者角色是 user，則無需操作
    else:
        flash(f'使用者 {user_to_demote.email} 已經是最低權限，無需變更。', 'info')

    # 6. 最終導向
    return redirect(url_for('admin_admins'))

#刪除使用者路由

@login_required 
@app.route('/admin/delete/<int:user_id>')
def delete_user(user_id):
    # 1. 權限檢查：確保是 Super Admin
    allowed_roles = ['super_admin']
    if current_user.role not in allowed_roles: 
        flash('權限不足！您沒有權限刪除使用者。', 'danger')
        return redirect(url_for('index'))

    # 2. 找到要刪除的使用者
    user_to_delete = User.query.get_or_404(user_id)

    # 3. 防護機制：防止 Admin 刪除自己的帳號 (重要!)
    if user_to_delete.id == current_user.id:
        flash('您不能刪除您自己的帳號！', 'danger')
        # 這裡應該導向管理員列表，而不是 admin_users (程式碼中沒有這個路由)
        return redirect(url_for('admin_admins')) 

    # 4. 執行刪除操作
    try:
        # 注意：Reservation 模型中已設定 cascade="all, delete-orphan"，刪除 User 時會自動刪除相關預約
        db.session.delete(user_to_delete)
        db.session.commit() # 🌟 確保這一行成功執行 🌟
        flash(f'使用者 {user_to_delete.email} 已成功從資料庫中刪除！', 'success')

    except Exception as e:
        db.session.rollback() # 如果出錯，回滾操作
        flash(f'刪除失敗：發生錯誤。錯誤：{e}', 'danger')

    # 最終導向：根據被刪除者的角色導向正確的清單
    if user_to_delete.role == 'user':
        return redirect(url_for('admin_researchers'))
    else:
        return redirect(url_for('admin_admins'))

#新增 Super Admin 升級路由

@login_required 
@app.route('/admin/promote_super/<int:target_user_id>', methods=['GET', 'POST'])
def promote_super_admin(target_user_id):
    # 1. 權限檢查：只有 Admin (admin 或 super_admin) 才能訪問這個頁面
    allowed_roles = ['admin', 'super_admin']
    if current_user.role not in allowed_roles:
        flash('權限不足！您沒有權限訪問此管理頁面。', 'danger')
        return redirect(url_for('index'))

    # 2. 確保只有 Super Admin 才能執行寫入操作
    if current_user.role != 'super_admin':
        flash('您需要總管理員權限才能執行此操作。', 'danger')
        return redirect(url_for('admin_admins'))

    # 3. 實例化表單並獲取目標使用者
    # 🚨 修正：您需要在 forms.py 中定義 Form，並確保已在頂部導入。
    try:
        from forms import SuperAdminForm
    except ImportError:
        # 如果 forms.py 中沒有這個表單，您將需要在該檔案中添加它
        flash("錯誤：缺少 SuperAdminForm 定義。請檢查 forms.py。", 'danger')
        return redirect(url_for('admin_admins'))

    form = SuperAdminForm()
    user_to_promote = User.query.get_or_404(target_user_id)

    # 4. 處理表單提交
    if form.validate_on_submit():
        if form.super_key.data == SUPER_ADMIN_KEY:
            # 密鑰正確，執行升級
            user_to_promote.role = 'super_admin'
            db.session.commit()
            flash(f'使用者 {user_to_promote.email} 已成功升級為總管理員 (Super Admin)！', 'success')
            return redirect(url_for('admin_admins'))
        else:
            # 密鑰錯誤
            flash('總管理員密鑰不正確，升級失敗。', 'danger')

    # 5. 渲染模板
    return render_template('promote_super_admin.html', 
                            form=form, 
                            user=user_to_promote,
                            target_user_id=target_user_id)


# 應用程式的啟動點
if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        print("資料庫表格已檢查並建立完成 (reservations.db)。")

    app.run(debug=True)
# ----------------------------------------------------

請除錯並給予詳細程式碼